---
title: "Working with dates and times"
description: |
  Introduction to lubridate for dates and times in R.
author:
  - name: Stephanie Hicks
    url: https://stephaniehicks.com/
    affiliation: Department of Biostatistics, Johns Hopkins
    affiliation_url: https://www.jhsph.edu
date: 10-05-2021
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 3
categories:
  - module 2
  - week 6
  - tidyverse
  - R 
  - programming
draft: TRUE
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<!-- Add interesting quote -->


# Pre-lecture materials

### Read ahead

:::resources

**Before class, you can prepare by reading the following materials:**

1. https://r4ds.had.co.nz/dates-and-times.html
2. 

:::


### Acknowledgements

Material for this lecture was borrowed and adopted from

- https://jhu-advdatasci.github.io/2018/lectures/09-dates-times.html
- https://r4ds.had.co.nz/dates-and-times.html
- 

# Learning objectives

:::keyideas

**At the end of this lesson you will:**

- 
- 
- 

:::


# Introduction

In this lesson, we will learn how to work with dates and times in R. 
These may seem simple as you use them all of the time in your day-to-day life, 
but the more you work with them, the more complicated they seem to get. 

Dates and times are hard because they have to reconcile two physical phenomena (the rotation of the Earth and its orbit around the sun) with a whole raft of geopolitical phenomena including months, time zones, and daylight savings time (DST). 

This lesson will not teach you every last detail about dates and times, but it will give you a solid grounding of practical skills that will help you with common data analysis challenges.




R has developed a special representation of dates and times

- Dates are represented by the `Date` class

- Times are represented by the `POSIXct` or the `POSIXlt` class

- Dates are stored internally as the number of days since 1970-01-01

- Times are stored internally as the number of seconds since
  1970-01-01

### The `lubridate` package

Here, we will focus on the `lubridate` R package, which makes it easier to work with dates and times in R. A few things to note about it: 

- It largely replaces the default date/time functions in base R

- It contains methods for date/time arithmetic

- It handles time zones, leap year, leap seconds, etc.

`lubridate` is not part of core `tidyverse` because you only need it when you are working with dates/times. 

```{r, eval=FALSE}
install.packages("lubridate") ## Not part of `tidyverse` package
```

```{r}
library(tidyverse)
library(lubridate) 
```


### Creating date/times

There are three types of date/time data that refer to an instant in time:

- A **date**. Tibbles print this as `<date>`.

- A **time** within a day. Tibbles print this as `<time>`.

- A **date-time** is a date plus a time: it uniquely identifies an instant in time (typically to the nearest second). Tibbles print this as `<dttm>`. Elsewhere in R these are called `POSIXct`. 

In this chapter we are only going to focus on dates and date-times as R does nort have a native class for storing times. If you need one, you can use the `hms` package.

You should always use the simplest possible data type that works for your needs. That means if you can use a date instead of a date-time, you should. Date-times are substantially more complicated because of the need to handle time zones, which we’ll come back to at the end of the chapter.

To get the current date or date-time you can use `today()` or `now()`:

```{r}
today()

now()
```

Otherwise, there are three ways you’re likely to create a date/time:

From a string.
From individual date-time components.
From an existing date/time object.
They work as follows.




# Dates in R

Dates are represented by the `Date` class and can be coerced from a character string using the `ymd()` function.

```{r,message=FALSE}
library(lubridate)
x <- ymd("1970-01-01")
x
class(x)
unclass(x)

x <- ymd("2019-10-03")
unclass(x)
```

`Date` objects have their own special print methods that will always format as "YYYY-MM-DD".

### Alternate Formulations

Different locales have different ways formatting dates

```{r}
ymd("2016-09-13")  ## International standard
ymd("2016/09/13")  ## Just figure it out
mdy("09-13-2016")  ## Mostly U.S.
dmy("13-09-2016")  ## Europe
```
All of the above are valid and lead to the exact same object.


Even if the individual dates are formatted differently, `ymd()` can usually figure it out.

```{r}
x <- c("2016-04-05", 
       "2016/05/06",
       "2016,10,4")
ymd(x)
```

# Times in R

Times are represented using the `POSIXct` or the `POSIXlt` class


- `POSIXct` is just a very large integer under the hood; it is a useful class when you want to store times in something like a data frame

- `POSIXlt` is a list underneath and it stores a bunch of other useful information like the day of the week, day of the year, month, day of the month

Times are represented as the number of *seconds* since 1970-01-01 00:00:00.

```{r}
x <- ymd_hms("2019-10-03 13:30:00")
class(x)
unclass(x)
```


If you want to know more about the international date/time standard, you can read about [ISO Standard 8601](https://en.wikipedia.org/wiki/ISO_8601).

### Inputing Time Data

Times can be coerced from a character string with `ymd_hms()`

```{r}
ymd_hms("2016-09-13 14:00:00")
ymd_hms("2016-09-13 14:00:00", tz = "America/New_York")
ymd_hms("2016-09-13 14:00:00", tz = "")
```

# Time Zones!

Time zones were created to make your data analyses more difficult.

* `ymd_hms()` function will by default use UTC as the time zone

* Specifying `tz = ""` will use the local time zone

* Better to specify time zone when possible to avoid ambiguity

You can go to Wikipedia to find the [list of time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)

* Daylight savings time

* Some states are in two time zones

* Southern hemisphere is opposite


# Specifying Times in R

Finally, there is the `strptime()` function in case your dates are
written in a different format

```{r,tidy=FALSE}
datestring <- c("January 10, 2012 10:40", 
                "December 9, 2011 9:10")
x <- strptime(datestring, "%B %d, %Y %H:%M", 
              tz = "America/Los_Angeles")
x
```

* Check `?strptime` for details of formatting strings

* When reading in data with `read_csv()`, you may need to read in as character first and then convert to date/time


# Operations on Dates and Times

### Arithmetic 

You can add and subtract dates and times. You can do comparisons too (i.e. `==`, `<=`)

```{r, error=TRUE}
x <- ymd("2012-01-01", tz = "")  ## Midnight
y <- dmy_hms("9 Jan 2011 11:34:21", tz = "")
x - y
x + y  ## Nope!
```



Add a second to a time
```{r}
y + 1
```
Just keep the date portion
```{r}
y <- date(y)
y
```
Add a number to the date (in this case 1 day)
```{r}
y + 1  
```

### Leaps and Bounds

Even keeps track of leap years, leap seconds, daylight savings, and time zones.

Leap years
```{r}
x <- ymd("2012-03-01")
y <- ymd("2012-02-28")
x - y
```


Beware of time zones!
```{r}
x <- ymd_hms("2012-10-25 01:00:00", tz = "")
y <- ymd_hms("2012-10-25 06:00:00", tz = "GMT")
y - x
```

There are also *leap seconds*.

```{r}
.leap.seconds
```

# Extracting Elements of Dates/Times

There are a set of helper functions in `lubridate` that can extract sub-elements of dates/times

### Date Elements
```{r}
x <- ymd_hms(c("2012-10-25 01:13:46",
               "2015-04-23 15:11:23"), tz = "")
year(x)
month(x)
day(x)
weekdays(x)
```

### Time Elements

```{r}
x <- ymd_hms(c("2012-10-25 01:13:46",
               "2015-04-23 15:11:23"), tz = "")
minute(x)
second(x)
hour(x)
week(x)
```



# Visualizing Dates


### Reading in the Data

```{r, warning=FALSE, message=FALSE}
library(here)
library(readr)
storm <- read_csv(here("data", "storms_2004.csv.gz"), progress = FALSE)
names(storm)
```

Let's take a look at the `BEGIN_DATE_TIME` and `DEATHS_DIRECT` variables

```{r,message=FALSE}
library(dplyr)
select(storm, BEGIN_DATE_TIME, EVENT_TYPE, DEATHS_DIRECT)
```

We can first convert the date/time to a date/time R object.

```{r}
storm_sub <- select(storm, BEGIN_DATE_TIME, EVENT_TYPE, DEATHS_DIRECT) %>%
  mutate(begin = dmy_hms(BEGIN_DATE_TIME)) %>%
  rename(type = EVENT_TYPE,
         deaths = DEATHS_DIRECT) %>%
  select(begin, type, deaths)
storm_sub
```


### Histograms of Dates/Times


We can make a histogram of the dates/times to get a sense of when storm events occur.

```{r}
library(ggplot2)
storm_sub %>%
  ggplot(aes(x = begin)) + 
  geom_histogram(bins = 20) + 
  theme_bw()
```

We can group by event type too.

```{r,fig.width=12,fig.height=12}
library(ggplot2)
storm_sub %>%
  ggplot(aes(x = begin)) + 
  facet_wrap(~ type) + 
  geom_histogram(bins = 20) + 
  theme_bw() + 
  theme(axis.text.x.bottom = element_text(angle = 90))
```

### Scatterplots of Dates/Times

```{r}
storm_sub %>%
  ggplot(aes(begin, deaths)) + 
  geom_point()
```

If we focus on a single month, the x-axis adapts.

```{r}
storm_sub %>%
  filter(month(begin) == 6) %>%
  ggplot(aes(begin, deaths)) + 
  geom_point()
```

Similarly, we can focus on a single day.

```{r}
storm_sub %>%
  filter(month(begin) == 6, day(begin) == 16) %>%
  ggplot(aes(begin, deaths)) + 
  geom_point()

```

# Summary

- Dates and times have special classes in R that allow for numerical and statistical calculations

- Dates use the `Date` class

- Times use the `POSIXct` and `POSIXlt` class

- Character strings can be coerced to Date/Time classes using the `ymd()` and `ymd_hms()` functions. In strange cases, you can use the `strptime()`or the `as.Date()` functions.

- The `lubridate` package is essential for manipulating date/time data

- Both `plot` and `ggplot` "know" about dates and times and will handle axis labels appropriately



# Post-lecture materials

### Final Questions 

Here are some post-lecture questions to help you think about the material discussed.

:::questions

**Questions:**

1. 

2. 

3.

:::


### Additional Resources 

:::resources 

- 
- 
- 

::: 
